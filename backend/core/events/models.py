"""
Event models for graph mutation events.

These models represent the structure of events generated by graph mutations
and the configuration for subscriptions/delivery.
"""

from enum import Enum
from typing import Optional, List, Dict, Any
from datetime import datetime
from pydantic import BaseModel, Field
import uuid


class EventType(str, Enum):
    """Types of graph mutation events."""
    NODE_CREATE = "node.create"
    NODE_UPDATE = "node.update"
    NODE_DELETE = "node.delete"
    EDGE_CREATE = "edge.create"
    EDGE_UPDATE = "edge.update"
    EDGE_DELETE = "edge.delete"


class EntityKind(str, Enum):
    """Kind of entity that triggered the event."""
    NODE = "node"
    EDGE = "edge"


class EventOrigin:
    """Common event origin values."""
    WEB_UI = "web-ui"
    MCP = "mcp"
    SYSTEM = "system"

    @staticmethod
    def agent(agent_id: str) -> str:
        """Create an agent origin string."""
        return f"agent:{agent_id}"

    @staticmethod
    def is_agent_origin(origin: str) -> bool:
        """Check if origin is from an agent."""
        return origin is not None and origin.startswith("agent:")

    @staticmethod
    def get_agent_id(origin: str) -> Optional[str]:
        """Extract agent ID from origin string."""
        if EventOrigin.is_agent_origin(origin):
            return origin.split(":", 1)[1]
        return None


class EventContext(BaseModel):
    """
    Context for event tracking and loop prevention.

    This context is passed through mutations and included in webhook payloads
    but is NOT stored in the graph itself.
    """
    event_origin: Optional[str] = Field(
        None,
        description="Source of the mutation (web-ui, mcp, system, agent:<id>)"
    )
    event_session_id: Optional[str] = Field(
        None,
        description="Unique session ID for loop prevention"
    )
    event_correlation_id: Optional[str] = Field(
        None,
        description="Correlation ID for chaining related events"
    )

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dict for JSON serialization."""
        return {
            "event_origin": self.event_origin,
            "event_session_id": self.event_session_id,
            "event_correlation_id": self.event_correlation_id,
        }


class EntityData(BaseModel):
    """
    Data about the entity (node or edge) that was mutated.
    """
    kind: EntityKind
    id: str
    type: str  # node.type or edge.type

    # For updates, we include both before and after states
    # For creates, before is None
    # For deletes, after is None
    before: Optional[Dict[str, Any]] = None
    after: Optional[Dict[str, Any]] = None

    # Optional: changed fields for updates
    patch: Optional[Dict[str, Any]] = None


class SubscriptionInfo(BaseModel):
    """
    Information about the subscription that matched this event.
    """
    id: str  # EventSubscription node ID
    name: str  # EventSubscription name (for readability)


class Event(BaseModel):
    """
    A graph mutation event that can be sent to webhooks.
    """
    event_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    event_type: EventType
    occurred_at: datetime = Field(default_factory=datetime.utcnow)

    # Origin context
    origin: EventContext

    # Entity data
    entity: EntityData

    # Subscription info (filled in when dispatching)
    subscription: Optional[SubscriptionInfo] = None

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }

    def to_webhook_payload(self) -> Dict[str, Any]:
        """Convert to the webhook payload format."""
        return {
            "event_id": self.event_id,
            "event_type": self.event_type.value,
            "occurred_at": self.occurred_at.isoformat() + "Z",
            "origin": self.origin.to_dict(),
            "entity": {
                "kind": self.entity.kind.value,
                "id": self.entity.id,
                "type": self.entity.type,
                "data": {
                    "before": self.entity.before,
                    "after": self.entity.after,
                    "patch": self.entity.patch,
                }
            },
            "subscription": {
                "id": self.subscription.id,
                "name": self.subscription.name,
            } if self.subscription else None,
        }


class DeliveryStatus(str, Enum):
    """Status of a webhook delivery attempt."""
    SUCCESS = "success"
    FAILED = "failed"
    RETRYING = "retrying"
    DROPPED = "dropped"  # Max retries exceeded


class DeliveryResult(BaseModel):
    """
    Result of attempting to deliver an event to a webhook.
    """
    event_id: str
    subscription_id: str
    webhook_url: str
    status: DeliveryStatus
    attempt: int
    max_attempts: int
    status_code: Optional[int] = None
    error_message: Optional[str] = None
    delivered_at: Optional[datetime] = None

    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat()
        }


# Subscription configuration models (stored in EventSubscription node metadata)

class KeywordFilters(BaseModel):
    """Keyword filters for matching events."""
    any: List[str] = Field(
        default_factory=list,
        description="Match if any of these keywords appear in name/description/summary/tags"
    )


class TargetFilters(BaseModel):
    """Target filters for what entities to match."""
    entity_kind: EntityKind = Field(
        default=EntityKind.NODE,
        description="Match node or edge events"
    )
    node_types: List[str] = Field(
        default_factory=list,
        description="Match specific node types (empty = all)"
    )
    relationship_types: List[str] = Field(
        default_factory=list,
        description="Match specific relationship types for edge events (empty = all)"
    )




class FederationFilters(BaseModel):
    """Federation scope filters for subscription matching."""
    scope: str = Field(
        default="local_only",
        description="local_only or local_and_federated"
    )
    include_graph_ids: List[str] = Field(
        default_factory=list,
        description="Optional allow-list of origin graph IDs"
    )
    max_distance: Optional[int] = Field(
        default=None,
        description="Optional max federation distance"
    )

class SubscriptionFilters(BaseModel):
    """
    Filter configuration for an EventSubscription.
    Stored in EventSubscription.metadata.filters
    """
    target: TargetFilters = Field(default_factory=TargetFilters)
    operations: List[str] = Field(
        default_factory=lambda: ["create", "update", "delete"],
        description="Which operations to match (create, update, delete)"
    )
    keywords: KeywordFilters = Field(default_factory=KeywordFilters)
    federation: FederationFilters = Field(default_factory=FederationFilters)


class SubscriptionDelivery(BaseModel):
    """
    Delivery configuration for an EventSubscription.
    Stored in EventSubscription.metadata.delivery
    """
    webhook_url: str = Field(
        ...,
        description="URL to POST events to"
    )
    ignore_origins: List[str] = Field(
        default_factory=list,
        description="Origins to ignore (for loop prevention)"
    )
    ignore_session_ids: List[str] = Field(
        default_factory=list,
        description="Session IDs to ignore (for loop prevention)"
    )
